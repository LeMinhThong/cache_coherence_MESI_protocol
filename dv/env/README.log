run string: make runall [TB_NAME=] [TEST_NAME=] [SEED=] [CMD_OPT=]
- default options:
  - TB_NAME=cache_mem_tb_top
  - TEST_NAME=cache_base_test // empty test
  - SEED=random
  - CMD_OPT=

//-------------------------------------------------------------------
operation list:
//-------------------------------------------------------------------
  L1 --> L2
    RD:   Read
    RFO:  Read for ownership // == RD + MARK_DIRTY
    MD:   Mark dirty
    WB:   Write back
  L1 <-- L2
    RD:     Read
    INV:    Invalidate
    RDINV:  Read then Invalidate // == RD + INV
  L2 --> SNP
    RD:   Read
    RFO:  Read for ownership
    INV:  Invalidate
    WB:   Write back
  L2 <-- SNP
    RD:   Read
    RFO:  Read for ownership
    INV:  Invalidate

//-------------------------------------------------------------------
behavior
//-------------------------------------------------------------------
CPU <--> L1 <--> L2 <--> SNP
// TODO: add response
L1 behavior
  receive CPU request
    read
      check cache miss or hit
        miss
          check block status
            invalid
              init RD: L1 --> L2
              response data CPU <-- L1
            tag_mismatch
              check upcoming evicted block
                clean
                  init RD: L1 --> L2
                  response data CPU <-- L1
                dirty:
                  init WB: L1 --> L2
                  init RD: L1 --> L2
                  // have to init 2 transaction because address is different
                  response CPU <-- L1
        hit: response data CPU <-- L1
    write
      check cache miss or hit
        miss
          check block status
            invalid
              init RFO: L1 --> L2
              assign data to block
            tag_mismatch
              check upcoming evicted block
                clean
                  init RFO: L1 --> L2
                  assign data to block
                dirty
                  init WB: L1 --> L2
                  init RFO: L1 --> L2
                  // have to init 2 transaction because address is different
                  assign data to block
        hit:
          init MD: L1 --> L2
          assign data to block
  receive L2 request
    RD
      check cache miss or hit
        miss: unreachable
        // L2 init RD because want update dirty block
        // miss indicates that L1 had eviected dirty block, but before that L1 has to init WB -> L2
        // if so L2 expected has up-to-date data -> no reason for L2 init RD
        hit
          check block state
            clean: unreachable // no reason for L2 init RD to clean block
            dirty
              deassert dirty
              response data L1 --> L2
    RDINV
      check cache miss or hit
        miss: unreachable 
        // L2 init RD because want update dirty block
        // miss indicates that L1 had eviected dirty block, but before that L1 has to init WB -> L2
        // if so L2 expected has up-to-date data -> no reason for L2 init RD
        hit:
          check block state
            clean: unreachable // no reason for L2 init RD to clean block
            dirty:
              invalid block
              response data L1 --> L2
    INV
      check cache miss or hit
        miss: bypass
        hit:
          check block state
            clean:
              invalid block
            dirty: unreachable // L2 is expected to init RDINV instead, because L2 aware that block is dirty

L2 behavior
  receive L1 request
    RD
      check cache miss or hit
        miss
          check block status
            inv:
              init RD: L2 --> SNP
              response data: L1 <-- L2 
            tag_mismatch:
              init RD: L2 --> SNP
              replacement
              response data: L1 <-- L2 
        hit:
          check block state
            clean:
              response data: L1 <-- L2
            dirty: unreachable // if dirty, this block has to be already located in L1
    RFO
      check cache miss or hit
        miss
          check block status
            inv:
              init SNP_RFO: L2 --> SNP
              assert dirty, set owner is L1
              response data: L1 <-- L2
            tag_mismatch:
              init SNP_RFO: L2 --> SNP
              replacement
              assert dirty, set owner is L1
              response data: L1 <-- L2
        hit
          check block state
            clean:
              init SNP_INV: L2 --> SNP
              assert dirty, set owner is L1
              response data: L1 <-- L2 
            dirty: unreachable // if dirty, this block has to be already located in L1
    MD
      check cache miss or hit
        miss: unreachable // MD is only initiated when CPU write hit on L1 -> this block has to be already located in L2(violated inclusivity property)
        hit:
          check block state
            clean:
              init SNP_INV: L2 --> SNP
              assert dirty, set owner is L1
            dirty: // this status occured while L1 write back block although snoop didnt request that location
              set owner is L1
    WB
      check cache miss or hit
        miss: unreachable // WB is only initiated when L1 want evict modified block -> this block has to be already located in L2(violated inclusivity property)
        hit:
          check block state
            clean: // FIXME unreachable (not sure) its expected dirty because L1 should has sent dirty anouncement before write back
              //init SNP_INV: L2 --> SNP
              //assert dirty, set owner is L2
              //assign data to block 
            dirty:
              set owner is L2
              assign data to block
  receive SNP request
    RD
      check cache miss or hit
        miss: bypass
        hit:
          check block state
            clean: response data: L2 --> L1
            dirty:
              check owner
                L1:
                  init RD: L1 <-- L2
                  init WB: L2 --> SNP
                  deassert dirty vs owner
                  response data: L2 --> SNP
                L2:
                  init WB: L2 --> SNP
                  deassert dirty vs owner
                  response data: L2 --> SNP
    RFO
      check cache miss or hit
        miss: bypass
        hit:
          check block state
            clean:
              invalid
              response data: L2 --> SNP
            dirty:
              check owner
                L1:
                  init RDINV: L1 <-- L2
                  init WB: L2 --> SNP
                  deassert dirty vs owner, invalid block
                  response data: L2 --> SNP
                L2:
                  init WB: L2 --> SNP
                  deassert dirty vs owner, invalid block
                  response data: L2 --> SNP
    INV
      check cache miss or hit
        miss: bypass
        hit:
          check block state
            clean: invalid block
            dirty: unreachable // INV is initated by other cache that want to modify shared block, if dirty so this block is only present in this cache

//-------------------------------------------------------------------
adjust to new version

find dir/ -type f -exec sed -i 's/old_pattern/new_pattern/g' {} +

l1_op_e   rx_l1_op    --> cd_op_e   cdr_op
address_t rx_l1_addr  --> address_t cdr_addr
data_t    rx_l1_data  --> data_t    cdr_data

                      --> cd_rsp_e  cdt_rsp
data_t    tx_l1_data  --> data_t    cdt_data

                      --> cu_op_e   cut_op
                      --> address_t cut_addr

                      --> cu_rsp_e  cur_rsp
                      --> data_t    cur_data

snp_op_e  tx_snp_op   --> sd_op_e   sdt_op
address_t tx_snp_addr --> address_t sdt_addr
                      --> data_t    sdt_data

snp_rsp_e rx_snp_rsp  --> sd_rsp_e  sdr_rsp
data_t    rx_snp_data --> data_t    sdr_data

snp_op_e  rx_snp_op   --> su_op_e   sur_op
address_t rx_snp_addr --> address_t sur_addr

snp_rsp_e tx_snp_rsp  --> su_rsp_e  sut_rsp
data_t    tx_snp_data --> data_t    sut_data

//-------------------------------------------------------------------
When IO signals were changed, adjust following files
- rtl
- cache_if
- cache_types & cache_def
- tb
- cache_txn (rand fields, uvm_object_utils, convert2string)
- cache_drv_bfm (init_signals, get_and_drive)
- cache_mon_bfm (asg_txn)

